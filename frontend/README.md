# What is a Thunk?

A **thunk** is a function that wraps another function or expression to delay its execution. In Redux, a **thunk** is a middleware pattern that allows you to write action creators that return functions instead of plain objects. This is useful for handling asynchronous logic, such as fetching data from an API or performing complex logic before dispatching actions.

<br>

---
<br>


### What is `createAsyncThunk`?
`createAsyncThunk` is a utility provided by Redux Toolkit to simplify the process of creating asynchronous thunks. It generates a thunk function that dispatches actions corresponding to the lifecycle of an async request: `pending`, `fulfilled`, and `rejected`.

### How It Works
1. You define an async thunk using createAsyncThunk.
2. It automatically generates three actions:
    - `pending`: Dispatched when the thunk starts executing.
    - `fulfilled`: Dispatched when the promise resolves successfully.
    - `rejected`: Dispatched when the promise is rejected or throws an error.

Example:
```js
export const fetchProducts = createAsyncThunk(
  'shop/fetchProducts',
  async (_, { rejectWithValue }) => {
    try {
      const response = await axios.get('/api/products');
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response.data);
    }
  }
);
```

## Custom Thunks

Custom thunks involve manually defining asynchronous logic within a thunk function (a higher-order function). They provide more control over dispatching actions.

Example:
```js
export const fetchProducts = () => async (dispatch) => {
  dispatch(fetchProductsStart()); // Custom action for starting fetch
  try {
    const response = await axios.get('/api/products');
    dispatch(fetchProductsSuccess(response.data));
  } catch (error) {
    dispatch(fetchProductsFailure(error.message));
  }
};
```

## Difference Between Custom Thunks and `createAsyncThunk`


|**Aspect**  |	**Custom Thunks**  |	`createAsyncThunk`  |
|------------|---------------------|----------------------|
|**Ease of Use**|	Requires manually defining actions and dispatch logic.|	Simplifies async action creation by auto-generating lifecycle actions.|
|**Control**|	Gives complete control over dispatch flow and custom logic.|	Limited to the predefined lifecycle actions (`pending`, `fulfilled`, `rejected`).|
|**Code Complexity**|	More boilerplate due to manually creating actions.|	Less boilerplate, as actions are auto-generated.|
|**Error Handling**|	Fully customizable; you can retry or dispatch multiple actions for errors.|	Limited to the `rejected` action for error handling.|
|**Flexibility**|	Can easily integrate additional dispatches or logic (e.g., logging, analytics).|	Less flexible; logic has to fit into the `fulfilled` or `rejected` lifecycle.|
|**Learning Curve**|	Requires understanding Redux and middleware deeply.|	Easier for beginners, as it abstracts complexity.|
|**Debugging**|	Easier to debug custom flow due to explicit dispatches.|	Debugging is tied to autogenerated actions.|
|**Scalability**|	Suitable for complex workflows with multiple API calls.|	Ideal for simple async workflows.|



---
<br>


### Pros and Cons

**Custom Thunks**

**Pros**:
- Full control over the flow of dispatches.
- Flexible for handling multiple dependent API calls.
- Easily integrates complex error-handling and retry mechanisms.

**Cons**:

- More boilerplate code.
- Requires manually creating and managing actions.
- Higher learning curve for beginners.

`createAsyncThunk`

**Pros**:

- Simplifies async logic with autogenerated lifecycle actions.
- Reduces boilerplate code.
- Easier for beginners to implement.

**Cons**:

- Limited to the predefined async lifecycle (harder to add custom dispatches).
- Less flexibility for handling interdependent API calls.
- Error handling is less customizable.
<br>
---
<br>

### Which Should You Use?
- Use `createAsyncThunk` if:

    - Your app has simple async operations like fetching or posting data.
    - You want to reduce boilerplate and prefer auto-generated actions.

- Use **Custom Thunks** if:

    - Your app requires complex workflows or dependent API calls.
    - You need full control over dispatching additional actions (e.g., analytics or caching).
    - You want to customize error handling and retry logic.

For most e-commerce applications, **custom thunks** are better suited for scalability and flexibility. However, for simpler features, `createAsyncThunk` can still be a good choice.
